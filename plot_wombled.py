import argparse
import ast
import sys
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.basemap import Basemap
from scipy.ndimage import label

parser = argparse.ArgumentParser(prog='Womble plotter',
                                 description='Plot saved data from womble.py',
                                 formatter_class=argparse.RawDescriptionHelpFormatter)

required_arguments = parser.add_argument_group('required arguments')
required_arguments.add_argument('-p', '--prefix', type=str,
                                help='Prefix for rates-of-change, directions, longitudes, and latitudes files produced '
                                     'by womble.py. Uses weighted direction-of-change by default. Individual files can '
                                     'be overridden by calling other arguments (e.g. -d direction-of-change.txt).')
required_arguments.add_argument('--density', type=ast.literal_eval,
                                help='Density (per unit longitude and latitude) used to generate grid. Required if '
                                     'using the "prefix" option (tuple of length 2, e.g.: "(2, 2)" ).')
required_arguments.add_argument('-r', '--rates', type=str,
                                help='Rates-of-change file generated by womble.py for each point on the grid.')
required_arguments.add_argument('-d', '--directions', type=str,
                                help='Directions-of-change file generated by womble.py for every point of the grid.'
                                     ' (weighted direction of change is preferred.')
required_arguments.add_argument('-g', '--longitudes', type=str,
                                help='File with longitudes of the grid generated by womble.py')
required_arguments.add_argument('-t', '--latitudes', type=str,
                                help='File with latitudes of the grid generated by womble.py')
parser.add_argument('-c', '--percentile', required=False, default=5., type=float,
                    help='Only plot the grid-squares of the top N-th percentile (default: 5, meaning that '
                         'the top 1 in 20 tiles (top by absolute rate of change) will be shown).')
parser.add_argument('-a', '--alpha', required=False, type=float, default=0.0,
                    help='The opacity of the heat-map of rates of change (Default: 0; 0 <= alpha <= 1).')

args = parser.parse_args()

lats = longs = rateOfChange = directionOfChange = None  # only to remove IDE's warnings
if args.prefix:
    if not args.density:
        RuntimeError("Density is a required argument when using 'prefix'")
    if not (type(args.density) is tuple):
        raise TypeError('DENSITY must be a tuple of size 2 (e.g.: "(1, 1)", input: {} )'.format(args.density))
    elif len(args.density) != 2:
        raise IndexError('DENSITY must be a tuple of size 2 (e.g.: "(1, 1)", input: {} )'.format(args.density))
    else:
        print('Using density:  {}'.format(args.density), file=sys.stderr)

    lats = np.loadtxt(args.prefix + "_latitudes_{}_{}.txt".format(args.density[0], args.density[1]))
    longs = np.loadtxt(args.prefix + "_longitudes_{}_{}.txt".format(args.density[0], args.density[1]))
    rateOfChange = np.loadtxt(args.prefix +
                              "_rateOfChange_{}_{}.txt".format(args.density[0], args.density[1]))
    directionOfChange = np.loadtxt(args.prefix +
                                   "_weightedDirOfChange_{}_{}.txt".format(args.density[0], args.density[1]))

if args.latitudes:
    lats = np.loadtxt(args.latitudes)
elif not args.prefix:
    RuntimeError("Provide file with latitudes.")

if args.longitudes:
    longs = np.loadtxt(args.longitudes)
elif not args.prefix:
    RuntimeError("Provide file with longitudes.")

if args.rates:
    rateOfChange = np.loadtxt(args.rates)
elif not args.prefix:
    RuntimeError("Provide file with rates.")

if args.directions:
    directionOfChange = np.loadtxt(args.directions)
elif not args.prefix:
    RuntimeError("Provide file with directions.")

mid_lats, mid_longs = np.meshgrid(lats, longs)

# How this ought to work:
# Using a percentile, select regions with the top N-th percentile rates-of-change. These are the core regions.
#    The 2nd N-th percentile is to be used as a "linked"; they are only to be plotted if they are connected to
#    regions in the top N-th percentile. Plot quivers for only the core regions and connected regions in the
#    2nd N-th percentile.
# 1. Find 1st and 2nd N-th percentile cutoffs
gridSize = len(rateOfChange.ravel().tolist())
if args.percentile > 50:
    perc = 50
elif int(args.percentile * gridSize / 100) < 1:
    perc = 100 / gridSize
else:
    perc = args.percentile
cutoff_1, cutoff_2 = np.array([value[0] for value in
                               sorted(zip((rateOfChange.ravel().tolist()),
                                          range(len(rateOfChange.ravel().tolist()))),
                                      reverse=True)])[[int(perc * gridSize/100),
                                                       int(perc * 2 * gridSize/100)]]

# 2. Use rate-of-change matrix to find regions within the top first 2 N-th percentiles.
grid_labeled, num_features = label(rateOfChange > cutoff_2,
                                   structure=[[1, 1, 1],
                                              [1, 1, 1],
                                              [1, 1, 1]])
for label_ in np.unique(grid_labeled):
    if label_ not in np.unique(grid_labeled[rateOfChange > cutoff_1]):
        grid_labeled[grid_labeled == label_] = 0

m = Basemap(projection='cyl',
            llcrnrlat=min(lats),
            urcrnrlat=max(lats),
            llcrnrlon=min(longs),
            urcrnrlon=max(longs),
            resolution='i')
#m.drawcoastlines(linewidth=0.5)
m.drawmapboundary(fill_color='#bfffff', zorder=0)
m.fillcontinents(color='#ffffff',lake_color='#bfffff', zorder=1)

plt.tight_layout(pad=0, h_pad=0, w_pad=0)

plt.imshow(np.fliplr(rateOfChange).T,
           extent=[longs.min(), longs.max(),
                   lats.min(), lats.max()],
           cmap="Reds", alpha=args.alpha, zorder=2)

plt.quiver(mid_longs[grid_labeled > 0], mid_lats[grid_labeled > 0],  # Longitude, Latitude
           np.cos(directionOfChange[grid_labeled > 0]),
           np.sin(directionOfChange[grid_labeled > 0]),
           headwidth=0, headlength=0, color="Black",
           headaxislength=0, width=0.005, pivot='mid', zorder=3)

plt.show()
